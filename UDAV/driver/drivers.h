#ifndef DRIVERS_H
#define DRIVERS_H

#include <QMap>
#include <QVariant>
#include <QVector>

#include "drivers_global.h"



//! Модуль драйверов оборудования и виртуальных симуляторов.
/**
 * Состоит из набора констант классов, обеспечивающих быструю разработку драйверов нового оборудования.
 *
 * Условно модуль можно разделить три независимых блока:
 * 1. Блок объявлений констант и вспомогательных классов;
 * 2. Блок классов пользовательского интерфейса;
 * 3. Блок базового интерфейса драйверов оборудования.
 *
 * <h3>Блок объявлений констант и вспомогательных классов</h3>
 *
 * Содержит объявления констант и вспомогательных классов, обеспечивающих базовый функционал модуля.
 *
 * Работа с оборудованием строится на модели сигналов. Сигналы делятся на 2 вида: сигналы наблюдения
 * и сигналы управления.
 *
 * Сигналы наблюдения - это данные, поступающие с различных датчиков и индикаторов оборудования. Сигналы
 * управления - это команды, передаваемые исполнительным устройствам оборудования, на выполнение конкретных
 * действий.
 *
 * Сигналы характеризуются номером и значением. Номера сигналов задаются с помощью мнемонических констант.
 * По соглашению константы номеров сигналов наблюдения имеют префикс VS_, а сигналов управления CS_.
 *
 * В настроящий момент времени сигналы могут иметь номера в диапазоне от 0 до 255.
 * Для сигналов управления зарезервирован диапазон 0...127. Для сигналов управления 128...254.
 *
 * Номер 255 зарезервирован для сигнала, не имеющего привязки.
 *
 * @sa SignalID, CS_Begin, VS_Begin
 *
 * Для описания сигналов, предоставляемых драйвером оборудования служит структура MetaSignal.
 *
 * После подключения программы-клиента к оборудования ему передается массив метасигналов.
 *
 * <h3>Блок классов пользовательского интерфейса</h3>
 *
 * Бла-бла...
 *
 * <h3>Блок программного интерфейса драйверов оборудования</h3>
 *
 * Блок состоит из двух классов: DriverInterface и DriverImpl.
 *
 * Физически драйверы оборудования реализованы в виде динамических подключаемых библиотек (плагинов), что
 * позволяет подключать к системе новое оборудование без модификации основного ядра системы.
 *
 * Класс DriverInterface является оберткой для класса реальной реализации работы с оборудованием.
 *
 * Экземпляр DriverInterface автоматически создается и загружается в память при запуске сервера.
 * Далее, по мере поступления запросов от пользователя на подключение к оборудованию экземпляр
 * DriverInterface создает экзепляр DriverImpl, который выполяняет фактические действия по взаимодействию
 * между программой-клиентом и драйвером.
 *
 * Это связано с тем, что с одним экземпляром реального оборудования, как правило, может в один момент времени
 * может работать только один пользователь, а с виртуальным неограниченное количество пользователей.
 *
 * При написании драйвера реального оборудования необходимо наследовать новый класс от класса DriverInterface
 * и от класса DriverImpl.
 *
 */
namespace udav_drivers
{

class DriverInterface;

const int CommandOk = 0;
const int CommandError = 1;

/**
 * @brief Тип для идентификаторов сигналов.
 */
typedef quint16 SignalID;

/**
 * @brief Начальный номер сигнала управления.
 */
const SignalID CS_Begin = 0;

/**
 * @brief Начальный номер сигнала наблюдения. Зарезервирован для передачи текущего времени
 */
const SignalID VS_Begin = 32768;

/**
 * @brief Тип для хранения значений сигналов, передаваемых от САУ оборудования.
 *
 * Значения сигналов хранятся в карте соответствия QMap<qint16, QVariant>.
 * Доступ к значению сигнала осуществляется по его индексу.
 * Индекс 0 зарезервирован для сообщения о сигнале, который не привязан к датчикам.
 */
typedef QMap<SignalID, QVariant> SignalValues;

/**
 * @brief Итератор в стиле JAVA для доступа к элементам массива значений сигналов.
 *
 * @sa SignalValues
 */
typedef QMapIterator<SignalID, QVariant> SignalValuesJavaStyleIterator;

/**
 * @brief Итератор в для доступа к элементам массива значений сигналов.
 *
 * @sa SignalValues
 */
typedef QMap<SignalID, QVariant>::iterator SignalValuesIterator;

/**
 * @brief Константный итератор для доступа к элементам массива значений сигналов.
 *
 * @sa SignalValues
 */
typedef QMap<SignalID, QVariant>::const_iterator SignalValuesConstIterator;

/**
 * @brief EquipmentArray
 */
typedef QVector<udav_drivers::DriverInterface*> EquipmentArray;

}


#endif // DRIVERS_H
