#ifndef SERVER_SIDE_SOCKET_H
#define SERVER_SIDE_SOCKET_H

#include <QtGlobal>
#include <QTcpSocket>
#include <QVector>
#include <QUuid>

#include "udavs.h"

#include "drivers.h"

class QTimer;

namespace Drivers
{
    class DriverImpl;
}

namespace Core
{

class Server;

/**
* @brief Класс обрабатывающий подключение клиента и отвечающий за обмен данными.
*/
class ServerSideSocket : public QTcpSocket
{
    Q_OBJECT
    private :

        /**
         * @brief Массив значений ответов, ожидаемых от клиента.
         *
         * Используется при разборе данных, поступающих от клиента.
         * В первую очередь поступающий ответ проверяется на вхождение в массив ожидаемых данных.
         * Процедура отправки данных на клиента должна заполнить массив допустимыми вариантами ответа.
         *
         * Пакет с недопустимым типом данных будет проигнорирован сервером.
         *
         * Очистка массива производится в методе readDataFromClient() после обработки поступающих данных.
         */
        QVector<quint8> allowedReplies_;

        /**
         * @brief Таймер проверки соединения с клиентом.
         *
         * Когда таймер срабатывает, сервер отправляет клиенту пакет для проверки наличия связи.
         * Если клиент не ответил три раза подряд, то связь считается потерянной.
         */
        QTimer* connectionCheckTimer_;

        /**
         * @brief Флаг, показывающий, что соединение с клиентом установлено.
         *
         * Этот флаг означает не то, что есть физический канал связи, а то, что процесс инициализации соединения
         * в соответствии с протоколом успешно завершен. Упешно прошел процесс обмена рукопожатием,
         * выбор драйвера, и теперь в штатном режиме идет обмен значениями сигналов.
         */
        bool isConnected_;

        /**
         * @brief Таймер отправки данных сигналов наблюдения клиенту.
         *
         * Когда таймер срабатывает сервер отправляет клиенту набор данных сигналов наблюдения.
         */
        QTimer* dataSendTimer_;

        /**
         * @brief Указатель на реализацию драйвера оборудования, выбранного пользователем.
         *
         * Именно реализация драйвера обеспечивает связь и управление работой оборудования.
         */
        Drivers::DriverImpl* driverImpl_;

        /**
         * @brief Код последнего запроса, отправленного клиенту.
         *
         * Используется при анализе ответа, полученного от клиента.
         */
        quint8 lastRequest_;

        /**
         * @brief Количество отправленныз пакетов контроля соединения, на которые не пришел ответ от клиента.
         *
         * После превышения количества пакетов величины больше допустимой связь считается потерянной
         * и соединение закрывается. @todo #105 Оборудование в этом случае должно быть переведено в режим аварийного
         * останова или в режим автопилота (в зависимости от настроек).
         *
         */
        quint8 lostPackets_;

        /**
         * @brief Размер следующего блока данных.
         *
         * Если от клиента получен размер блока 0xFFFF, то это означает, что клиент закрыл соединение.
         */
        quint32 nextBlockSize_;

        /**
         * @brief Указатель на объект сервера, создавшего сокет.
         */
        Server* server_;

    public:

        /**
         * @brief Конструктор по умолчанию.
         * @param parent - объект-владелец; им должен быть экземпляр класса Server, которому принадлежит сокет.
         *
         * Создает экземпляр класса и инициализирует внутренние переменные.
         */
        explicit ServerSideSocket(Server* parent);

        /**
          * @brief Деструктор.
          *
          * При уничтожении объекта освобождает память, выделенную объектам драйверов при работе с клиентом.
          */
        ~ServerSideSocket();

    private slots:

        /**
         * @brief Проверяет полученный от клиента пакет рукопожатия (HANDSHAKE) на корректность.
         * @param clientName
         * @param clientVersion
         * @param message - в случае ошибки проверки в переменную будет записано диагностическое сообщение.
         * @return true, если проверка успешна; false, если проверка неуспешно.
         */
        bool checkHandShake_(const QString& clientName, const QString& clientVersion, QString& message);

        /**
         * @brief Читает и обрабатывает данные, поступающие от клиента.
         *
         * @todo #106 Вынести отдельно описание протокола
         *
         * Процесс обработки данных зависит от их типа и текущего состояния системы.
         *
         * Первоначально при поступлении данных от клиента сбрасываются счетчики потерянных пакетов и перзапускаются
         * таймеры проверки связи, так как наличие запроса означает, что связь с клиентом есть.
         *
         * Далее идет проверка пакетов, которые обрабатываются вне очереди. Это пакеты с наивысшим приоритетом:
         *
         * 1. Если клиент по каким-либо причинам запросил разрыв соединения пакетом RefuseConnection, то соединение закрывается.
         * 2. Если клиент запросил передачу файла, то запрошенный файл отправляется клиенту немедленно @todo Вроде устарело и не используется. Проверить передачу SVG схем
         * 3. Если клиент передал набор настроек драйвера оборудования, то они передаются драйверу сразу. @todo Пока не реализовано. Надо подумать, надо ли. Вроде надо в режиме отладки.
         *
         * После этого проверяется допустимость полученного от клиента запроса. Допустимые запросы хранятся в массиве allowedReplies_
         * Если запрос ошибочен, то соединение с клиентом закрывается с выдачей соответствующего сообщения.
         * @todo Надо не закрывать соединение, а отправлять сообщение клиенту об ошибке. Иначе ошибки на стороне клиента приведут к разрыву соединения
         *
         * Обмен данными можно разбить на 2 фазы.
         * 1. Инициализация соединения
         * 2. Работа при установленном соединении
         *
         * Инициализация соединения происходит по следующему алгоритму:
         *
         * 1. Клиент присылает запрос на установку соединения (RequestConnection).
         *
         * В случае возможности установки соединения у сервера запрашивается uuid сессии и клиенту отправляется ConnectionOk и uuid.
         * В случае невозможности установки соединения клиенту отправляется пакет RefuseConnection и сообщение о причине отказа.
         *
         * 2. Клиент отправляет серверу пакет рукопожатия (HandShake), в котором содержатся сведения о версии программы.
         *
         * Сервер проверяет полученный пакет рукопожатия на правильность и в случае его правильности отправляет клиенту свой пакет рукопожатия.
         * Если полученный пакет неверен, то клиенту отправляется пакет RefuseConnection и сообщение о причине отказа. Соединение закрывается.
         *
         * 3. Если клиент посчитал пакет рукопожатия, полученный от сервера правильным, он отправляет ConnectionOk, в противном случае RefuseConnection.
         *
         * 4. В этот момент клиент может прислать один из пакетов:
         * - запрос подключения без билета
         * - запрос списка доступных драйверов оборудования
         *
         * В любом случае клиенту отправляется список доступных драйверов оборудования и сервер переходит в режим
         * ожидания сведений о выбранном на стороне клиента драйвере оборудования.
         *
         * 5. Если клиент присылает uuid выбранного драйвера, то производится попытка загрузки драйвера.
         *
         * Если загрузка драйвера оказалась успешной, то клиенту последовательно отправляются:
         * - сведения о метасигналах драйвера (MetaSignals)
         * - сведения о пользовательском интерфейсе драйвера для отображения панели управления оборудованием (UiDescription)
         * - сведения о настройках драйвера @todo В планах, пока не реализовано
         *
         * В загруженном драйвере запускается процесс регулярного чтения состояния устройств .
         *
         * Соединение считается установленным.
         *
         * Работа в режиме установленного соединения происходит по следующему алгоритму:
         *
         * 1. Когда драйвер читает состояние устройств, то он сообщает об этом серверу, и сервер отправляет клиенту пакет ViewArray
         *
         * 2. Когда драйвер считает необходимым обновить изображение мнемосхемы, то он сообщает об этом серверу, и сервер отправляет клиенту пакет Visualisation
         *
         * 3. Клиент может прислать серверу управляющий сигнал Control. Сервер передает его драйверу оборудования.
         *
         * Если драйвер оборудования успешно обрабатывает сигнал, то он сообщает об этом серверу, и сервер отправляет клиенту сообщение ControlOk.
         * Если драйвер не может обработать сигнал, то он сообщает об этом серверу, и сервер отправляет клиенту сообщение ControlError.
         *
         * 4. Клиент в любой момент времени может прислать серверу сигнал на закрытие соединения (RefuseConnection)
         */
        void readDataFromClient_();


        /**
         * @brief sendBoolSignalValue
         * @param signalId
         * @param signalValue
         * @param message
         *
         * @todo Стоит Q_ASSERT(false) Удалить?
         */
        void sendBoolSignalValue(Drivers::SignalID signalId, bool signalValue, QString message = QString());

        /**
         * @brief Отправляет клиенту пакет проверки соединения CheckConnection.
         */
        void sendCheckConnection_();

        /**
         * @brief Отправляет клиенту пакет отказа обработки сигнала управления (Control error)
         * @param signalID - Номер сигнала, в обработке которого было отказано
         * @param message - диагностическое сообщение, передаваемое клиенту
         */
        void sendControlError_(Drivers::SignalID signalID, const QString& message);

        /**
         * @brief Отправляет клиенту пакет, подтверждающий успешную обработку сигнала управления (Control Ok).
         */
        void sendControlOk_();

        /**
         * @brief Передает клиенту значения всех сигналов управления в одном пакете данных.
         *
         * @todo Ничего не делает. Удалить?
         */
        void sendControlSignals_();

        /**
         * @brief Отправляет клиенту сведения о текущих настройках выбранного драйвера оборудования.
         *
         * @todo Ничего не делает. Релизовать?
         */
        void sendDriverSettings_();

        /**
         * @brief Отправляет клиенту список загруженных и доступных для использования вариантов оборудования.
         */
        void sendDriversList_();

        /**
         * @brief Отправляет клиенту файл.
         * @param fname - имя передаваемого файла.
         */
        void sendFile_(const QString& fname);

        /**
         * @brief Отправляет клиенту пакет рукопожатия (HANDSHAKE).
         */
        void sendHandShake_();

        /**
         * @brief Отправляет клиенту подтверждение успешной установки связи.
         *
         * Получает от сервера uuid сессии связи и инициализирует соединение.
         * После удачной инициализации соединения отправляет клиенту пакет ConnectionOK и uuid сессии.
         */
        void sendInitConnection_();

        /**
         * @brief Отправляет клиенту сведения о сигналах драйвера оборудования, используемого клиентом в текущей сессии.
         */
        void sendMetaSignals_();

        void sendOpenMessageWindow_(const QUuid& uuid, const QString& header);

        void sendCloseMessageWindow_(const QUuid& uuid, quint16 time, bool autoClose);

        void sendTextMessage2Window_(const QUuid& uuid, quint16 type, const QString& message);

        /**
         * @brief Отправляет клиенту пакет отказа соединения (RefuseConnection).
         * @param reason - причина отказа в соединении.
         *
         * Причина отказа указывается в передаваемом сообщении.
         * После отправки пакета соединение принудительно закрывается.
         */
        void sendRefuseConnection_(const QString& reason);

        /**
         * @brief Отправляет клиенту значение сигнала
         * @param signalID - Номер сигнала
         * @param message - Сообщение клиенту
         */
        void sendSignalValue_(Drivers::SignalID signalID, const QString& message = "");

        /**
         * @brief Отправляет клиенту текстовое сообщение
         * @param channel
         * @param message
         *
         * @todo Сопоставить с отправкой значений сигналов. Или текстовые сообщений это еще один вид сигнала?
         */
        //void sendTextMessage_(Drivers::SignalID channel, QString message);

        /**
         * @brief Отправляет клиенту сведения об интерфейсных элементах управления оборудованием.
         */
        void sendUiDescription_();

        /**
         * @brief Передает клиенту значения всех сигналов наблюдения в одном пакете данных.
         *
         * @todo Стандартизовать и задокументировать передачу значений сигналов. Очень много вариантов.
         */
        void sendViewSignals_();

        void sendSignals_();

        /**
         * @brief Слот вызывается по сигналу disconnected().
         *
         * Служит передачи серверу сигнала о том, что надо удалить сессию текущего сокета.
         */
        void socketDisconnected_()
        {
            emit disconnected(this);
        }

    signals :

        /**
         * @brief Сигнал сообщает о закрытиии соединения.
         * @param socket - адрес текущего сокета (this)ыс
         */
        void disconnected(ServerSideSocket* socket);

    signals: // Система записи лог-файлов

        /**
         * @brief Отправляет сообщение о критической ошибке
         * @param message - текст сообщения
         */
        void criticalMessage(const QString& message) const;

        /**
         * @brief Отправляет отладочное сообщение
         * @param message - текст сообщения
         */
        void debugMessage(const QString& message) const;

        /**
         * @brief Отправляет информационное сообщение
         * @param message - текст сообщения
         */
        void infoMessage(const QString& message) const;
};

}

#endif // SERVER_SIDE_SOCKET_H
