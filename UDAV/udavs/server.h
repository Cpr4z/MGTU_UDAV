#ifndef UDAV_SERVER_H
#define UDAV_SERVER_H

#include <QTcpServer>
#include <QMap>
#include <QVector>
#include <QUuid>

#include "drivers.h"
#include "factories.h"

namespace Drivers
{
    class DriverImpl;
}

namespace Core
{

class ServerSideSocket;

/**
 * @brief Класс сервера, отвечающего за обмен данными с клиентами.
 *
 * Хранит сведения обо всех сессиях связи с клиентами. Реальный обмен данными осуществляется
 * в классе ServerSideSocket. Данный класс отвечает только за управление сессиями:
 * их открытие, инициализаци и закрытие.
 *
 * Также хранит сведения о подключенном через драйвер оборудовании или его симуляторе
 * и осуществляет обмен с ним через драйвер оборудования.
 */
class Server : public QTcpServer
{
    Q_OBJECT

    friend Server* Factories::createServer(QObject *parent);

    private:

        /**
         * @brief Список открытых сессий связи с клиентами
         *
         * Ассоциативный массив данных, хранящий сведения об открытых сессиях связи с клиентами.
         * В массиве хранятся указатели на сессии обмена данными, так как потомки класса QObject,
         * как правило, не имеют операторов копирования и конструкторов копирования.
         *
         * Идентификация сессий производится по уникальному идентификатору uuid.
         */
        QMap<QUuid, ServerSideSocket*> sessions_;

        /**
         * @brief Подключенные к серверу и доступные пользователям варианты оборудования
         */
        Drivers::EquipmentArray equipment_;

    protected:
        /**
         * @brief Отвечает на входящее соединение, инициализирует сессию и запускает процесс обмена данными с клиентом.
         * @param socketId - идентификатор сокета соединения
         */
        virtual void incomingConnection(qintptr socketId);

    private:

        /**
         * @brief Конструктор по умолчанию.
         * @param parent
         *
         * Конструктор находится в закрытой секции для того, чтобы экземпляр класса можно было
         * создать только с помощью функции-фабрики. Это гарантирует правильную инициализацию
         * подсистемы вывода сообщений.
         */
        Server(QObject *parent = 0);


        /**
         * @brief Загружает доступные драйверы оборудования
         */
        void loadDrivers_();

    private slots:

        /**
         * @brief Находит сессию, соединение с которой закрыто и удаляет ее из массива открытых сессий.
         * @param socket - сокет закрываемой сессии
         */
        void connectionClosed_(ServerSideSocket *socket);

        /**
         * @brief Останавливает сервер, если передан символ 'q'
         * @param ch - передаваемый символ
         *
         * Функция задумана как механизм для отработки команд с клавиатуры. Пока ее ценность сомнительна,
         * так как сервер надо запускать в безтерминальном режиме.
         */
        void consoleKeyPressed_(char ch);


    public:

        /**
          * @brief Деструктор
          *
          * Освобождает занимаемую драйверами оборудования память.
          */
        ~Server();

        /**
         * @brief Формирует уникальный идентификатор новой сесии и возращает его
         * @return Идентификатор сессии
         *
         * Сессия сохраняется в массиве открытых сессий.
        */
        QString addSession_(ServerSideSocket* s);

        /**
         * @brief Удаляет сессию с переданным uuid из массива открытых сессий
         * @param uuid - идентификатор удаляемой сессии
         */
        void deleteSession_(const QUuid& uuid);

        /**
         * @brief Создает экземпляр реализации драйвера оборудования и возвращает указатель на него
         * @param uuid - уникальный идентификатор драйвера
         * @return Указательна созданный экземпляр реализации драйвера оборудования.
         *
         * Экземпляр класса реализации драйвера оборудования будет создан при вызове этого метода.
         * Если драйвера с запрашиваемым идентификатором не найдено, возвращает NULL.
         */
        Drivers::DriverImpl* getDriver(const QUuid& uuid);

        /**
         * @brief Возвращает ссылку на массив доступных драйверов оборудования.
         * @return Ссылка на массив доступных драйверов оборудования.
         */
        const Drivers::EquipmentArray& getDriversArray() const
        {
            return equipment_;
        }

        /**
         * @brief Возвращает уникальный идентификатор сессии, связанной с сокетом
         * @param socket - TCP сокет
         * @return Уникальный идентификатор. Если для сокета нет сессии, возвращается пустое значение идентификатора.
         */
        QUuid getSessionUuid(ServerSideSocket* socket);

    signals:

        /**
         * @brief Сигнал выдается сервером в момент его остановки.
         */
        void serverStopped();

    signals: // Система записи сообщений лог-файлов

        /**
         * @brief Отправляет сообщение о критической ошибке
         * @param message - текст сообщения
         */
        void criticalMessage(const QString& message) const;

        /**
         * @brief Отправляет отладочное сообщение
         * @param message - текст сообщения
         */
        void debugMessage(const QString& message) const;

        /**
         * @brief Отправляет информационное сообщение
         * @param message - текст сообщения
         */
        void infoMessage(const QString& message) const;

};

//-----------------------------------------------------------------------------

}

#endif // UDAV_SERVER_H
